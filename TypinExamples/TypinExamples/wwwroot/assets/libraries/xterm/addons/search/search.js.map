{"version":3,"file":"search.js","sources":["../../../src/addons/search/search.ts","../../../src/addons/search/SearchHelper.ts","../../../node_modules/browser-pack/_prelude.js"],"sourcesContent":["/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { SearchHelper } from './SearchHelper';\nimport { Terminal } from 'xterm';\nimport { ISearchAddonTerminal, ISearchOptions } from './Interfaces';\n\n/**\n * Find the next instance of the term, then scroll to and select it. If it\n * doesn't exist, do nothing.\n * @param term The search term.\n * @param searchOptions Search options\n * @return Whether a result was found.\n */\nexport function findNext(terminal: Terminal, term: string, searchOptions: ISearchOptions = {}): boolean {\n  const addonTerminal = <ISearchAddonTerminal>terminal;\n  if (!addonTerminal.__searchHelper) {\n    addonTerminal.__searchHelper = new SearchHelper(addonTerminal);\n  }\n  return addonTerminal.__searchHelper.findNext(term, searchOptions);\n}\n\n/**\n * Find the previous instance of the term, then scroll to and select it. If it\n * doesn't exist, do nothing.\n * @param term The search term.\n * @param searchOptions Search options\n * @return Whether a result was found.\n */\nexport function findPrevious(terminal: Terminal, term: string, searchOptions: ISearchOptions): boolean {\n  const addonTerminal = <ISearchAddonTerminal>terminal;\n  if (!addonTerminal.__searchHelper) {\n    addonTerminal.__searchHelper = new SearchHelper(addonTerminal);\n  }\n  return addonTerminal.__searchHelper.findPrevious(term, searchOptions);\n}\n\nexport function apply(terminalConstructor: typeof Terminal): void {\n  (<any>terminalConstructor.prototype).findNext = function(term: string, searchOptions: ISearchOptions): boolean {\n    return findNext(this, term, searchOptions);\n  };\n\n  (<any>terminalConstructor.prototype).findPrevious = function(term: string, searchOptions: ISearchOptions): boolean {\n    return findPrevious(this, term, searchOptions);\n  };\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { ISearchHelper, ISearchAddonTerminal, ISearchOptions, ISearchResult } from './Interfaces';\nimport { IDisposable } from 'xterm';\n\nconst NON_WORD_CHARACTERS = ' ~!@#$%^&*()+`-=[]{}|\\;:\"\\',./<>?';\nconst LINES_CACHE_TIME_TO_LIVE = 15 * 1000; // 15 secs\n\n/**\n * A class that knows how to search the terminal and how to display the results.\n */\nexport class SearchHelper implements ISearchHelper {\n  /**\n   * translateBufferLineToStringWithWrap is a fairly expensive call.\n   * We memoize the calls into an array that has a time based ttl.\n   * _linesCache is also invalidated when the terminal cursor moves.\n   */\n  private _linesCache: string[] = null;\n  private _linesCacheTimeoutId = 0;\n  private _cursorMoveListener: IDisposable | undefined;\n  private _resizeListener: IDisposable | undefined;\n\n  constructor(private _terminal: ISearchAddonTerminal) {\n    this._destroyLinesCache = this._destroyLinesCache.bind(this);\n  }\n\n  /**\n   * Find the next instance of the term, then scroll to and select it. If it\n   * doesn't exist, do nothing.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @return Whether a result was found.\n   */\n  public findNext(term: string, searchOptions?: ISearchOptions): boolean {\n    const {incremental} = searchOptions;\n    let result: ISearchResult;\n\n    if (!term || term.length === 0) {\n      this._terminal.clearSelection();\n      return false;\n    }\n\n    let startCol: number = 0;\n    let startRow = this._terminal.buffer.viewportY;\n\n    if (this._terminal.hasSelection()) {\n      // Start from the selection end if there is a selection\n      // For incremental search, use existing row\n      const currentSelection = this._terminal.getSelectionPosition();\n      startRow = incremental ? currentSelection.startRow : currentSelection.endRow;\n      startCol = incremental ? currentSelection.startColumn : currentSelection.endColumn;\n    }\n\n    this._initLinesCache();\n\n    // A row that has isWrapped = false\n    let findingRow = startRow;\n    // index of beginning column that _findInLine need to scan.\n    let cumulativeCols = startCol;\n    // If startRow is wrapped row, scan for unwrapped row above.\n    // So we can start matching on wrapped line from long unwrapped line.\n    while (this._terminal.buffer.getLine(findingRow).isWrapped) {\n      findingRow--;\n      cumulativeCols += this._terminal.cols;\n    }\n\n    // Search startRow\n    result = this._findInLine(term, findingRow, cumulativeCols, searchOptions);\n\n    // Search from startRow + 1 to end\n    if (!result) {\n\n      for (let y = startRow + 1; y < this._terminal.buffer.baseY + this._terminal.rows; y++) {\n\n        // If the current line is wrapped line, increase index of column to ignore the previous scan\n        // Otherwise, reset beginning column index to zero with set new unwrapped line index\n        result = this._findInLine(term, y, 0, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    // Search from the top to the startRow (search the whole startRow again in\n    // case startCol > 0)\n    if (!result) {\n      for (let y = 0; y < findingRow; y++) {\n        result = this._findInLine(term, y, 0, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    // Set selection and scroll if a result was found\n    return this._selectResult(result);\n  }\n\n  /**\n   * Find the previous instance of the term, then scroll to and select it. If it\n   * doesn't exist, do nothing.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @return Whether a result was found.\n   */\n  public findPrevious(term: string, searchOptions?: ISearchOptions): boolean {\n    let result: ISearchResult;\n\n    if (!term || term.length === 0) {\n      this._terminal.clearSelection();\n      return false;\n    }\n\n    const isReverseSearch = true;\n    let startRow = this._terminal.buffer.viewportY + this._terminal.rows - 1;\n    let startCol = this._terminal.cols;\n\n    if (this._terminal.hasSelection()) {\n      // Start from the selection start if there is a selection\n      const currentSelection = this._terminal.getSelectionPosition();\n      startRow = currentSelection.startRow;\n      startCol = currentSelection.startColumn;\n    }\n\n    this._initLinesCache();\n\n    // Search startRow\n    result = this._findInLine(term, startRow, startCol, searchOptions, isReverseSearch);\n\n    // Search from startRow - 1 to top\n    if (!result) {\n      // If the line is wrapped line, increase number of columns that is needed to be scanned\n      // Se we can scan on wrapped line from unwrapped line\n      let cumulativeCols = this._terminal.cols;\n      if (this._terminal.buffer.getLine(startRow).isWrapped) {\n        cumulativeCols += startCol;\n      }\n      for (let y = startRow - 1; y >= 0; y--) {\n        result = this._findInLine(term, y, cumulativeCols, searchOptions, isReverseSearch);\n        if (result) {\n          break;\n        }\n        // If the current line is wrapped line, increase scanning range,\n        // preparing for scanning on unwrapped line\n        if (this._terminal.buffer.getLine(y).isWrapped) {\n          cumulativeCols += this._terminal.cols;\n        } else {\n          cumulativeCols = this._terminal.cols;\n        }\n      }\n    }\n\n    // Search from the bottom to startRow (search the whole startRow again in\n    // case startCol > 0)\n    if (!result) {\n      const searchFrom = this._terminal.buffer.baseY + this._terminal.rows - 1;\n      let cumulativeCols = this._terminal.cols;\n      for (let y = searchFrom; y >= startRow; y--) {\n        result = this._findInLine(term, y, cumulativeCols, searchOptions, isReverseSearch);\n        if (result) {\n          break;\n        }\n        if (this._terminal.buffer.getLine(y).isWrapped) {\n          cumulativeCols += this._terminal.cols;\n        } else {\n          cumulativeCols = this._terminal.cols;\n        }\n      }\n    }\n\n    // Set selection and scroll if a result was found\n    return this._selectResult(result);\n  }\n\n  /**\n   * Sets up a line cache with a ttl\n   */\n  private _initLinesCache(): void {\n    if (!this._linesCache) {\n      this._linesCache = new Array(this._terminal.buffer.length);\n      this._cursorMoveListener = this._terminal.onCursorMove(() => this._destroyLinesCache());\n      this._resizeListener = this._terminal.onResize(() => this._destroyLinesCache());\n    }\n\n    window.clearTimeout(this._linesCacheTimeoutId);\n    this._linesCacheTimeoutId = window.setTimeout(() => this._destroyLinesCache(), LINES_CACHE_TIME_TO_LIVE);\n  }\n\n  private _destroyLinesCache(): void {\n    this._linesCache = null;\n    if (this._cursorMoveListener) {\n      this._cursorMoveListener.dispose();\n      this._cursorMoveListener = undefined;\n    }\n    if (this._resizeListener) {\n      this._resizeListener.dispose();\n      this._resizeListener = undefined;\n    }\n    if (this._linesCacheTimeoutId) {\n      window.clearTimeout(this._linesCacheTimeoutId);\n      this._linesCacheTimeoutId = 0;\n    }\n  }\n\n  /**\n   * A found substring is a whole word if it doesn't have an alphanumeric character directly adjacent to it.\n   * @param searchIndex starting indext of the potential whole word substring\n   * @param line entire string in which the potential whole word was found\n   * @param term the substring that starts at searchIndex\n   */\n  private _isWholeWord(searchIndex: number, line: string, term: string): boolean {\n    return (((searchIndex === 0) || (NON_WORD_CHARACTERS.indexOf(line[searchIndex - 1]) !== -1)) &&\n        (((searchIndex + term.length) === line.length) || (NON_WORD_CHARACTERS.indexOf(line[searchIndex + term.length]) !== -1)));\n  }\n\n  /**\n   * Searches a line for a search term. Takes the provided terminal line and searches the text line, which may contain\n   * subsequent terminal lines if the text is wrapped. If the provided line number is part of a wrapped text line that\n   * started on an earlier line then it is skipped since it will be properly searched when the terminal line that the\n   * text starts on is searched.\n   * @param term The search term.\n   * @param row The line to  start the search from.\n   * @param col The column to start the search from.\n   * @param searchOptions Search options.\n   * @return The search result if it was found.\n   */\n  protected _findInLine(term: string, row: number, col: number, searchOptions: ISearchOptions = {}, isReverseSearch: boolean = false): ISearchResult {\n\n    // Ignore wrapped lines, only consider on unwrapped line (first row of command string).\n    if (this._terminal.buffer.getLine(row).isWrapped) {\n      return;\n    }\n    let stringLine = this._linesCache ? this._linesCache[row] : void 0;\n    if (stringLine === void 0) {\n      stringLine = this.translateBufferLineToStringWithWrap(row, true);\n      if (this._linesCache) {\n        this._linesCache[row] = stringLine;\n      }\n    }\n\n    const searchTerm = searchOptions.caseSensitive ? term : term.toLowerCase();\n    const searchStringLine = searchOptions.caseSensitive ? stringLine : stringLine.toLowerCase();\n\n    let resultIndex = -1;\n    if (searchOptions.regex) {\n      const searchRegex = RegExp(searchTerm, 'g');\n      let foundTerm: RegExpExecArray;\n      if (isReverseSearch) {\n        // This loop will get the resultIndex of the _last_ regex match in the range 0..col\n        while (foundTerm = searchRegex.exec(searchStringLine.slice(0, col))) {\n          resultIndex = searchRegex.lastIndex - foundTerm[0].length;\n          term = foundTerm[0];\n          searchRegex.lastIndex -= (term.length - 1);\n        }\n      } else {\n        foundTerm = searchRegex.exec(searchStringLine.slice(col));\n        if (foundTerm && foundTerm[0].length > 0) {\n          resultIndex = col + (searchRegex.lastIndex - foundTerm[0].length);\n          term = foundTerm[0];\n        }\n      }\n    } else {\n      if (isReverseSearch) {\n        if (col - searchTerm.length >= 0) {\n          resultIndex = searchStringLine.lastIndexOf(searchTerm, col - searchTerm.length);\n        }\n      } else {\n        resultIndex = searchStringLine.indexOf(searchTerm, col);\n      }\n    }\n\n    if (resultIndex >= 0) {\n      // Adjust the row number and search index if needed since a \"line\" of text can span multiple rows\n      if (resultIndex >= this._terminal.cols) {\n        row += Math.floor(resultIndex / this._terminal.cols);\n        resultIndex = resultIndex % this._terminal.cols;\n      }\n      if (searchOptions.wholeWord && !this._isWholeWord(resultIndex, searchStringLine, term)) {\n        return;\n      }\n\n      const line = this._terminal.buffer.getLine(row);\n\n      for (let i = 0; i < resultIndex; i++) {\n        const cell = line.getCell(i);\n        // Adjust the searchIndex to normalize emoji into single chars\n        const char = cell.char;\n        if (char.length > 1) {\n          resultIndex -= char.length - 1;\n        }\n        // Adjust the searchIndex for empty characters following wide unicode\n        // chars (eg. CJK)\n        const charWidth = cell.width;\n        if (charWidth === 0) {\n          resultIndex++;\n        }\n      }\n      return {\n        term,\n        col: resultIndex,\n        row\n      };\n    }\n  }\n  /**\n   * Translates a buffer line to a string, including subsequent lines if they are wraps.\n   * Wide characters will count as two columns in the resulting string. This\n   * function is useful for getting the actual text underneath the raw selection\n   * position.\n   * @param line The line being translated.\n   * @param trimRight Whether to trim whitespace to the right.\n   */\n  public translateBufferLineToStringWithWrap(lineIndex: number, trimRight: boolean): string {\n    let lineString = '';\n    let lineWrapsToNext: boolean;\n\n    do {\n      const nextLine = this._terminal.buffer.getLine(lineIndex + 1);\n      lineWrapsToNext = nextLine ? nextLine.isWrapped : false;\n      lineString += this._terminal.buffer.getLine(lineIndex).translateToString(!lineWrapsToNext && trimRight).substring(0, this._terminal.cols);\n      lineIndex++;\n    } while (lineWrapsToNext);\n\n    return lineString;\n  }\n\n  /**\n   * Selects and scrolls to a result.\n   * @param result The result to select.\n   * @return Whethera result was selected.\n   */\n  private _selectResult(result: ISearchResult): boolean {\n    if (!result) {\n      this._terminal.clearSelection();\n      return false;\n    }\n    this._terminal.select(result.col, result.row, result.term.length);\n    this._terminal.scrollLines(result.row - this._terminal.buffer.viewportY);\n    return true;\n  }\n}\n",null],"names":[],"mappings":"AEAA;;;ADQA;AACA;AAKA;AAWA;AAAA;AALA;AACA;AAKA;AACA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAGA;AACA;AACA;AACA;AAGA;AAGA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AASA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AAKA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAaA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAzUa;;;;;ADTb;AAWA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AARA;"}